{"version":3,"sources":["webpack://ld2h/webpack/bootstrap","webpack://ld2h/external \"$rdf\"","webpack://ld2h/./node_modules/rdfgraphnode-rdfext/lib/GraphNode.js","webpack://ld2h/./src/ld2h.js","webpack://ld2h/./node_modules/rdf2h/lib/rdf2h.js","webpack://ld2h/external \"fetch\"","webpack://ld2h/./node_modules/mustache/mustache.js","webpack://ld2h/./node_modules/rdf2h/lib/vocab.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","$rdf","_defineProperties","target","props","length","descriptor","configurable","writable","_construct","Parent","args","Class","Reflect","construct","sham","Proxy","Date","toString","e","isNativeReflectConstruct","a","push","apply","instance","Function","_setPrototypeOf","arguments","setPrototypeOf","__proto__","fetch","Headers","h","window","GraphNode","Impl","Array","slice","_class","nodes","graph","sources","Constructor","TypeError","_classCallCheck","this","_graph","isArray","protoProps","staticProps","_createClass","_this","termType","indexOf","split","Promise","resolve","uri","rdfFetch","then","response","node","f","_this2","results","map","all","_this3","_this4","predicate","each","statementsMatching","undefined","statement","subject","Error","options","login","ggg","init","headers","set","ok","reject","mediaType","text","parse","error","plainFetch","status","console","log","rdf","RDF2h","LD2h","replaceElement","element","newElement","document","createElement","nodeName","attributes","setAttribute","innerHTML","parentNode","insertBefore","remove","insertHTML","htmlString","test","tmp","hasChildNodes","scripts","getElementsByTagName","from","firstChild","appendChild","setHtmlContent","content","head","body","expand","canonicalize","url","div","href","getRenderersGraph","renderers","getDataGraph","localData","expandWithRenderers","resultPromises","renderElems","getElementsByClassName","elem","classList","context","getAttribute","resolveCurie","relativeURI","render","sym","warn","fetchElems","_loop","relativeGraphURI","graphUri","catch","data","rendered","stack","dataElem","getElementById","serializedRDF","tagName","outerHTML","serializationFormat","location","err","result","renderersElem","src","Accept","j","rendererLinks","querySelectorAll","graphPromises","Mustache","vocab","rendererGraphs","tbox","reverse","env","rdf2h","origLokup","Context","lookup","view","Renderee","resolvePath","path","pathSections","string","readingURI","lastCharLess","section","nextSection","pos","splitPathSection","resolveSubPath","subNode","endsWith","substring","startsWith","out","resolveSection","resultNodes","language","equals","literal","datatype","graphNode","prefixPart","splits","iriPart","prefix","iri","prefixMap","subContext","nodePath","resolvedNodes","getRenderer","renderee","self","types","sort","b","rdfs","match","localeCompare","concat","getTypes","renderer","reverseGraphs","reduce","type","typeGN","find","getMatching","getMatchingRenderer","join","mustache","rendererRenderer","js","output","returnValue","message","stackLines","lineWithSelf","findIndex","splice","curie","suffix","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","global","factory","objectToString","isFunction","escapeRegExp","replace","hasProperty","obj","propName","primitiveHasOwnProperty","primitive","regExpTest","RegExp","nonSpaceRe","isWhitespace","re","testRegExp","entityMap","&","<",">","\"","'","/","`","=","whiteRe","spaceRe","equalsRe","curlyRe","tagRe","Scanner","tail","parentContext","cache",".","parent","Writer","eos","scan","index","scanUntil","search","intermediateValue","names","lookupHit","clearCache","template","tags","cacheKey","tokens","openingTagRe","closingTagRe","closingCurlyRe","sections","spaces","hasTag","nonSpace","stripSpace","pop","compileTags","tagsToCompile","start","chr","token","openSection","scanner","valueLength","charAt","nestedTokens","collector","numTokens","nestTokens","lastToken","squashedTokens","squashTokens","parseTemplate","partials","renderTokens","originalTemplate","symbol","buffer","renderSection","renderInverted","renderPartial","unescapedValue","escapedValue","rawValue","escape","version","defaultWriter","typeStr","to_html","send","String","schema","foaf"],"mappings":"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","file":"ld2h.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = $rdf;","\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar $rdf = require(\"ext-rdflib\");\n\nvar fetch = require(\"node-fetch\");\n/**\n * Node Status:\n * \n * Locally undetermined: There are multiple local nodes satisfying the criteria specified for this object \n * Blank: The object represents a blank node in a graph that is locally available\n * Unresolved: This node is identified by a URI that has not yet been derefernced\n * \n * @type type\n */\n\n\nvar Headers = function (h) {\n  return h ? h : window.Headers;\n}(fetch.Headers);\n\nfunction GraphNode() {\n  return _construct(GraphNode.Impl, Array.prototype.slice.call(arguments));\n}\n\nGraphNode.Impl =\n/*#__PURE__*/\nfunction () {\n  function _class(nodes, graph, sources) {\n    _classCallCheck(this, _class);\n\n    this._graph = graph;\n\n    if (Array.isArray(nodes)) {\n      this.nodes = nodes;\n      /*if (this.nodes.length === 0) {\n          throw \"Can't represent empty set of nodes\";\n      }*/\n    } else {\n      this.nodes = [nodes];\n    }\n\n    this.sources = sources;\n  }\n\n  _createClass(_class, [{\n    key: \"fetch\",\n    value: function fetch() {\n      var _this = this;\n\n      if (this.termType !== \"NamedNode\" || this.sources && this.sources.indexOf(this.value.split(\"#\")[0]) > -1) {\n        return Promise.resolve(this);\n      } else {\n        //TODO extend existing graph?\n        var uri = this.value.split(\"#\")[0];\n        return GraphNode.rdfFetch(uri).then(function (response) {\n          return response.graph();\n        }).then(function (graph) {\n          return GraphNode(_this.node, graph, [uri]);\n        });\n      }\n    }\n    /*\n     * \n     * @param {type} f\n     * @returns {unresolved} a promise that is satisfied when all promises returned by f are resolved\n     */\n\n  }, {\n    key: \"each\",\n    value: function each(f) {\n      var _this2 = this;\n\n      var results = this.nodes.map(function (node) {\n        return f(GraphNode([node], _this2.graph, _this2.sources));\n      });\n      return Promise.all(results);\n    }\n  }, {\n    key: \"fetchEach\",\n    value: function fetchEach(f) {\n      var _this3 = this;\n\n      var results = this.nodes.map(function (node) {\n        return GraphNode([node], _this3.graph, _this3.sources).fetch().then(f);\n      });\n      return Promise.all(results);\n    }\n    /**\n     * Returns a GraphNode for each node represented by this GraphNode\n     */\n\n  }, {\n    key: \"split\",\n    value: function split() {\n      var _this4 = this;\n\n      return this.nodes.map(function (node) {\n        return GraphNode([node], _this4.graph, _this4.sources);\n      });\n    }\n  }, {\n    key: \"out\",\n    value: function out(predicate) {\n      var nodes = this.graph.each(this.node, predicate);\n      /*if (nodes.length === 0) {\n          throw \"No property \"+predicate+\" on \"+this.node;\n      }*/\n\n      return GraphNode(nodes, this.graph, this.sources);\n    }\n  }, {\n    key: \"in\",\n    value: function _in(predicate) {\n      var statements = this.graph.statementsMatching(undefined, predicate, this.node);\n      /*if (statements.length === 0) {\n          throw \"No property \"+predicate+\" pointing to \"+this.node;\n      }*/\n\n      return GraphNode(statements.map(function (statement) {\n        return statement.subject;\n      }), this.graph, this.sources);\n    }\n  }, {\n    key: \"graph\",\n    get: function get() {\n      if (!this._graph) {\n        throw Error(\"Operation not possible as no Graph is available, try fetching first\");\n      }\n\n      return this._graph;\n    }\n  }, {\n    key: \"node\",\n    get: function get() {\n      if (this.nodes.length !== 1) {\n        throw Error(\"Operation not possible as this GraphNode is underdetermined\");\n      }\n\n      return this.nodes[0];\n    }\n  }, {\n    key: \"termType\",\n    get: function get() {\n      return this.node.termType;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      ;\n      return this.node.value;\n    }\n  }]);\n\n  return _class;\n}();\n/**\n * \n * Fetches an RDF graph. If the server return 401 the login process will be \n * started upon which the fetch will be retried.\n *\n * @param uri {string} The URI to be fetched\n * @param options passed to $rdf.Fetcher\n * @param login {boolean} The login function to be called, optional\n *\n * @return {Promise<Response>} Response has a `graph`property with the rertived graph\n */\n\n\nGraphNode.rdfFetch = function (uri, options, login) {\n  function plainFetch(uri) {\n    var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!init.headers) {\n      init.headers = new Headers();\n    }\n\n    if (!init.headers.get(\"Accept\")) {\n      init.headers.set(\"Accept\", \"text/turtle;q=1, application/n-triples;q=.9, \" + \"application/rdf+xml;q=.8, application/ld+json;q=.7, */*;q=.1\");\n    }\n\n    return fetch(uri, init).then(function (response) {\n      if (response.ok) {\n        response.graph = function () {\n          return new Promise(function (resolve, reject) {\n            var graph = $rdf.graph();\n            var mediaType = response.headers.get(\"Content-type\").split(\";\")[0];\n            return response.text().then(function (text) {\n              $rdf.parse(text, graph, uri, mediaType, function (error, graph) {\n                if (error) {\n                  reject(error);\n                } else {\n                  resolve(graph);\n                }\n              });\n            });\n          });\n        };\n\n        return response;\n      } else {\n        return response;\n      }\n    });\n  }\n\n  ;\n  var ggg = this;\n  return plainFetch(uri, options).then(function (response) {\n    if (response.status < 300) {\n      return response;\n    } else {\n      if (login && response.status === 401) {\n        console.log(\"Got 401 response, attempting to login\");\n        return login().then(function () {\n          return ggg.rdfFetch(uri, options);\n        });\n      } else {\n        return response;\n      }\n    }\n  });\n};\n\nmodule.exports = GraphNode;\n//# sourceMappingURL=GraphNode.js.map","var rdf = require('ext-rdflib');\nvar RDF2h = require('rdf2h');\nvar GraphNode = require(\"rdfgraphnode-rdfext\");\n\n\nfunction LD2h() {\n}\n\n//LD2h.store = new LdpStore();\n\n//Needed for inserted scripts to be executed\nfunction replaceElement(element) {\n    const newElement = document.createElement(element.nodeName);\n    //copy attributes (eg. src)\n    for (let i = 0; i < element.attributes.length; i++) {\n        newElement.setAttribute(element.attributes[i].name, element.attributes[i].value);\n    }\n    newElement.innerHTML = element.innerHTML;\n    element.parentNode.insertBefore(newElement, element);\n    element.remove();\n}\n\nfunction insertHTML(node, htmlString) {\n    node.innerHTML = \"\";\n    //innerHTML should work if no scripts are included\n    if (!/<script/i.test(htmlString)) {\n        try {\n            node.innerHTML = htmlString;\n        }\n        //fail silently and try elaborated method below\n        catch (e) {}\n    }\n    //if innerHTML failed or wasn't executed\n    if (node.innerHTML === \"\") {\n        const tmp = document.createElement(node.nodeName);\n        tmp.innerHTML = htmlString;\n        if (tmp.hasChildNodes()) {\n            let scripts = tmp.getElementsByTagName(\"script\");\n            if (scripts.length > 0) {\n                scripts = Array.from(scripts)\n                for (let i = 0; i < scripts.length; i++) {\n                    replaceElement(scripts[i]);\n                }\n            }\n            //tmp.firstChild is live, so this will move all children\n            while (tmp.firstChild) {\n                console.log(tmp.firstChild)\n                node.appendChild(tmp.firstChild);\n            }\n        } else {\n            console.log(\"no children\");\n        }\n    }\n}\n\nfunction setHtmlContent(node, content) {\n    if (node.nodeName === \"HTML\") {\n        let tmp = document.createElement(\"html\");\n        tmp.innerHTML = content;\n        let head = tmp.getElementsByTagName(\"head\")[0].innerHTML;\n        let body = tmp.getElementsByTagName(\"body\")[0].innerHTML;\n        insertHTML(node.getElementsByTagName(\"head\")[0], head);\n        insertHTML(node.getElementsByTagName(\"body\")[0], body);\n    } else {\n        node.innerHTML = content;\n    }\n}\n\nLD2h.expand = function() {\n    function canonicalize(url) {\n        //see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue/22918332#22918332\n        var div = document.createElement('div');\n        div.innerHTML = \"<a></a>\";\n        div.firstChild.href = url; // Ensures that the href is properly escaped\n        div.innerHTML = div.innerHTML; // Run the current innerHTML back through the parser\n        return div.firstChild.href;\n    }\n    return LD2h.getRenderersGraph().then(function (renderers) {\n        return LD2h.getDataGraph().then(function (localData) {       \n            function expandWithRenderers() {\n                var resultPromises = new Array();\n                //Rendering with local RDF\n                let renderElems = document.getElementsByClassName(\"render\");\n                for (var i = 0; i < renderElems.length; i++) {\n                    let elem = renderElems[i];\n                    elem.classList.remove(\"render\");\n                    var context = elem.getAttribute(\"context\")\n                    if (context) {\n                        context = RDF2h.resolveCurie(context);\n                    }\n                    var relativeURI = elem.getAttribute(\"resource\");\n                    if (typeof relativeURI !== 'undefined') {\n                        var uri = canonicalize(relativeURI);\n                        var rendered = new RDF2h(renderers).render(localData, rdf.sym(uri), context);\n                        setHtmlContent(elem, rendered);\n                        resultPromises.push(expandWithRenderers());\n                    } else {\n                        console.warn(\"Element of class render without resource attribute cannot be rendered.\", elem);\n                    }\n                }\n                //Remote resources\n                let fetchElems = document.getElementsByClassName(\"fetch\");\n                for (var i = 0; i < fetchElems.length; i++) {\n                    let elem = fetchElems[i];\n                    elem.classList.remove(\"fetch\")\n                    var context = elem.getAttribute(\"context\");\n                    if (context) {\n                        context = RDF2h.resolveCurie(context);\n                    }\n                    var relativeURI = elem.getAttribute(\"resource\");\n                    if ((relativeURI !== null) && (typeof relativeURI !== 'undefined')) {\n                        var uri = canonicalize(relativeURI);\n                        var relativeGraphURI = elem.getAttribute(\"graph\");\n                        var graphUri;\n                        if (relativeGraphURI) { //empty strings are ignored\n                            graphUri = canonicalize(relativeGraphURI);\n                        } else {\n                            graphUri = uri.split(\"#\")[0];\n                        }\n                        GraphNode.rdfFetch(graphUri).catch(function(error) {\n                                        console.warn(\"Error retrieving \"+graphUri+\": \"+error);\n                                    }).then(function(response) {\n                                        return response.graph().then(\n                                            data =>  {\n                                                console.log(\"Got graph of size \"+data.length+\" from \"+graphUri);\n                                                var rendered = new RDF2h(renderers).render(data, rdf.sym(uri), context);\n                                                setHtmlContent(elem, rendered);\n                                                return expandWithRenderers();\n                                            }\n                                        );\n                                }).catch(function(error) {\n                                    console.warn(\"Error rendering \"+graphUri+\": \"+error);\n                                    if (error.stack) {\n                                        console.warn(error.stack);\n                                    }\n                                });\n                    } else {\n                        console.warn(\"Element of class fetch without resource attribute cannot be rendered.\", elem);\n                    }\n                }\n                return Promise.all(resultPromises);\n            }\n            return expandWithRenderers();     \n        });\n    });\n       \n}\n\nLD2h.getDataGraph = function() {\n    return new Promise(function(resolve, reject) {\n        let dataElem  = document.getElementById(\"data\");\n        if (dataElem) {\n            let serializedRDF = dataElem.tagName == \"SCRIPT\" ? dataElem.innerHTML : dataElem.outerHTML;\n            let serializationFormat = dataElem.getAttribute(\"type\");\n            if (!serializationFormat) {\n                serializationFormat = dataElem.tagName == \"SCRIPT\" ? \"applictaion/ld+json\" : \"text/html\";\n            }\n            var data = rdf.graph();\n            rdf.parse(serializedRDF, data, window.location.toString().split('#')[0], serializationFormat, (err, result) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(result);\n                }\n            });\n        } else {\n            resolve(rdf.graph());\n        }\n    });\n};\n\nLD2h.getRenderersGraph = function () {\n    return new Promise(function(resolve, reject) {\n        function parse(serializedRDF, serializationFormat) {\n            var graph = rdf.graph();\n            if (!serializationFormat) {\n                serializationFormat = 'text/turtle';\n            }\n            rdf.parse(serializedRDF, graph, window.location.toString().split('#')[0], serializationFormat, () => resolve(graph));\n        }\n        let renderersElem = document.getElementById(\"renderers\");\n        if (renderersElem) {\n            let src = renderersElem.getAttribute(\"src\")\n            if (src) {\n                console.warn('Using script element with src causes is not recommended, use <link rel=\"renderers\" instead');\n                fetch(src,\n                    {headers: {\n                        \"Accept\": \"text/turtle\",\n                    }})\n                    .then(r => {\n                        if (r.ok) {\n                            return r.text();\n                        }\n                        throw new Error(src + \" responded with \" + r.status);\n                    })\n                    .then(j => {\n                        parse(j);\n                    })\n                    .catch(e => console.error(e));\n            } else {\n                var serializedRDF = renderersElem.innerHTML;\n                parse(serializedRDF, renderersElem.getAttribute(\"type\"));\n            }\n        } else {\n            let rendererLinks = document.querySelectorAll(\"link[rel='renderers']\");\n            console.log(rendererLinks);\n            if (rendererLinks.length > 0) {\n                let graphPromises = new Array();\n                for (let i = 0; i < rendererLinks.length; i++) {\n                    var href = rendererLinks[i].href.split('#')[0];\n                    graphPromises.push(GraphNode.rdfFetch(href).then(r => r.graph()));\n                }\n\n                resolve(Promise.all(graphPromises));\n                \n            } else {\n                console.warn(\"No renderers could be found, specify a script element with \\n\\\n                id renderers or link headers of type renderers\");\n            }\n        }\n    });\n};\n\nif (typeof window !== 'undefined') {\n    window.LD2h = LD2h;\n}\nif (typeof module !== 'undefined') {\n    module.exports = LD2h;\n}","\"use strict\";\n\nvar rdf = require(\"ext-rdflib\");\n\nvar GraphNode = require(\"rdfgraphnode-rdfext\");\n\nvar Mustache = require(\"mustache\");\n\nvar vocab = require(\"./vocab.js\");\n\nvar NodeSet = new Array();\n\nfunction RDF2h(rendererGraphs, tbox) {\n  function r2h(suffix) {\n    return rdf.sym(\"http://rdf2h.github.io/2015/rdf2h#\" + suffix);\n  }\n\n  if (!Array.isArray(rendererGraphs)) {\n    rendererGraphs = [rendererGraphs];\n  }\n\n  if (tbox) {\n    this.tbox = tbox;\n  } else {\n    this.tbox = rendererGraphs[0];\n  }\n\n  this.rendererGraphs = rendererGraphs.reverse();\n  this.env = {}; //this is to allow shared vars among renderers\n}\n\n(function () {\n  var r2h = vocab.rdf2h;\n  var origLokup = Mustache.Context.prototype.lookup;\n\n  Mustache.Context.prototype.lookup = function (name) {\n    if (this.view instanceof RDF2h.Renderee) {\n      var resolvePath = function resolvePath(path) {\n        function resolveSubPath(node, pathSections) {\n          function resolveSection(section) {\n            if (section === \".\") {\n              return node;\n            } else {\n              if (section.endsWith(\"<-\")) {\n                return node[\"in\"](RDF2h.resolveCurie(section.substring(0, section.length - 2)));\n              } else {\n                if (section.startsWith(\"^\")) {\n                  return node[\"in\"](RDF2h.resolveCurie(section.substring(1)));\n                } else {\n                  return node.out(RDF2h.resolveCurie(section));\n                }\n              }\n            }\n          }\n\n          var subNode = resolveSection(pathSections[0]);\n\n          if (pathSections.length === 1) {\n            var resultNodes = subNode.nodes;\n\n            if (resultNodes.length === 0) {\n              //handling pseudo properties of literals\n              if (node.nodes[0].language) {\n                if (RDF2h.resolveCurie(pathSections[0]).equals(rdf.sym(\"http://purl.org/dc/terms/language\"))) {\n                  return [rdf.literal(node.nodes[0].language)];\n                }\n              }\n\n              if (node.nodes[0].datatype) {\n                if (RDF2h.resolveCurie(pathSections[0]).equals(RDF2h.resolveCurie(\"rdf:type\"))) {\n                  return [node.nodes[0].datatype];\n                }\n              }\n            }\n\n            return resultNodes;\n          }\n\n          return resolveSubPath(subNode, pathSections.slice(1));\n        }\n\n        function splitPathSection(string) {\n          var result = [];\n          var readingURI = false;\n          var lastCharLess = false;\n          var section = \"\";\n\n          function nextSection() {\n            if (section.length > 0) {\n              result.push(section);\n              section = \"\";\n            }\n          }\n\n          for (var pos = 0; pos < string.length; pos++) {\n            var c = string[pos];\n\n            if (lastCharLess) {\n              if (c !== \"-\") {\n                nextSection();\n                readingURI = true;\n              }\n\n              section += \"<\";\n              lastCharLess = false;\n            }\n\n            if (c === \"<\") {\n              lastCharLess = true;\n              continue;\n            }\n\n            if (readingURI && c == \">\") {\n              section += c;\n              nextSection();\n              readingURI = false;\n              continue;\n            }\n\n            if (!readingURI && c == \"/\") {\n              nextSection();\n              continue;\n            }\n\n            section += c;\n          }\n\n          nextSection();\n          return result;\n        }\n\n        var pathSections = splitPathSection(path); // .split(\"/\").filter(function(e) { return e.length > 0})\n\n        return resolveSubPath(graphNode, pathSections);\n      };\n\n      var rdf2h = this.view.rdf2h;\n      var graphNode = this.view.graphNode;\n      var graph = graphNode.graph;\n      var context = this.view.context;\n\n      if (name.startsWith(\"@prefix \")) {\n        var splits = name.split(\" \");\n        var prefixPart = splits[1];\n        var iriPart = splits[2];\n        var prefix = prefixPart.substring(0, prefixPart.length - 1);\n        var iri = iriPart.substring(1, iriPart.length - 1);\n        RDF2h.prefixMap[prefix] = iri;\n        return \"\";\n      }\n\n      if (name.startsWith(\":render \")) {\n        var splits = name.split(\" \");\n        var nodePath = splits[1];\n        var subContext = splits[2];\n\n        if (subContext) {\n          subContext = RDF2h.resolveCurie(subContext);\n        }\n\n        if (!subContext) {\n          subContext = context;\n        }\n\n        var resolvedNodes = resolvePath(nodePath);\n\n        if (resolvedNodes.length > 1) {\n          console.warn(\"Argument of render evaluates to more than one node!\");\n        }\n\n        if (resolvedNodes.length > 0) {\n          return rdf2h.render(graph, resolvedNodes[0], subContext);\n        } else {\n          return \"\";\n        }\n      }\n\n      if (name.startsWith(\":continue\")) {\n        var splits = name.split(\" \");\n        var subContext = splits[1];\n\n        if (subContext) {\n          subContext = RDF2h.resolveCurie(subContext);\n        }\n\n        if (!subContext) {\n          subContext = context;\n        }\n\n        if (graphNode.nodes.length > 1) {\n          console.warn(\":continue invoked in context with more than one node, this shouldn't be possible!\");\n        }\n\n        return rdf2h.render(graph, graphNode.nodes[0], subContext);\n      }\n\n      if (name.startsWith(\"+\")) {\n        name = name.substring(1);\n        return resolvePath(name).length > 0;\n      }\n\n      var nodes = resolvePath(name);\n\n      if (nodes.length === 1) {\n        return new RDF2h.Renderee(rdf2h, GraphNode(nodes[0], graph), context);\n      } else {\n        return nodes.map(function (node) {\n          return new RDF2h.Renderee(rdf2h, GraphNode(node, graph), context);\n        });\n      }\n      /*var node = this.view;\n       if (name === \".\") {\n       return node;\n       } else {\n       return \"not supported: \"+name;\n       }*/\n\n    } else {\n      return origLokup.call(this, name);\n    }\n  };\n})();\n\nRDF2h.Renderee = function (rdf2h, graphNode, context) {\n  if (!graphNode.nodes) {\n    throw new Error(\"second argument must be a GraphNode\");\n  }\n\n  if (graphNode.nodes.length !== 1) {\n    throw new Error(\"Renderee must be a single node\");\n  }\n\n  this.rdf2h = rdf2h;\n  this.graphNode = graphNode;\n  this.context = context;\n};\n\nRDF2h.Renderee.prototype.toString = function () {\n  if (this.graphNode.value) {\n    return this.graphNode.value;\n  }\n\n  return this.graphNode.toString();\n};\n\nRDF2h.prototype.getRenderer = function (renderee) {\n  var r2h = vocab.rdf2h;\n  var tbox = this.tbox;\n\n  function matchesContext(cfRenderer) {\n    var contexts = cfRenderer.out(r2h(\"context\")).nodes;\n\n    if (contexts.length === 0) {\n      console.debug(\"renderer \" + cfRenderer + \" specifies no context, thus accepting it for \" + renderee.context);\n      return true;\n    }\n\n    return contexts.some(function (context) {\n      if (renderee.context.equals(context)) {\n        console.debug(\"renderer \" + cfRenderer + \" matches the context \" + renderee.context);\n        return true;\n      }\n    });\n  }\n\n  function resolveRendererNode(rendererURI) {\n    if (!window) {\n      return \"Could not get renderer: \" + rendererURI + \", no window object.\";\n    }\n\n    var pageURIPrefix = window.location + \"#\";\n\n    if (!rendererURI.startsWith(pageURIPrefix)) {\n      return \"Could not get renderer: \" + rendererURI + \", the prefix must be \" + pageURIPrefix + \".\";\n    }\n\n    var id = rendererURI.substring(pageURIPrefix.length);\n    return document.getElementById(id).textContent;\n  }\n\n  function rendererRenderer(renderer) {\n    return function (renderee) {\n      return Mustache.render(renderer, renderee);\n    };\n  }\n\n  function getTypes(graphNode) {\n    //the array might contain rdfs:Resource twice (at the end)\n    if (graphNode.node.termType === \"Literal\") {\n      return [graphNode.node.datatype];\n    } else {\n      return graphNode.out(vocab.rdf(\"type\")).nodes.sort(function (a, b) {\n        if (a.equals(b)) {\n          return 0;\n        }\n\n        if (a.equals(vocab.rdfs(\"Resource\"))) {\n          return 1;\n        }\n\n        if (b.equals(vocab.rdfs(\"Resource\"))) {\n          return -1;\n        }\n\n        if (tbox.match(a, vocab.rdfs(\"subClassOf\"), b).length === 0) {\n          if (tbox.match(b, vocab.rdfs(\"subClassOf\"), a).length === 0) {\n            return a.value.localeCompare(b.value);\n          } else {\n            return 1;\n          }\n        } else {\n          return -1;\n        }\n      }).concat([vocab.rdfs(\"Resource\")]);\n    }\n  }\n\n  var self = this;\n\n  function getMatchingRenderer(types, context) {\n    function getMatching(renderers) {\n      return renderers.find(function (renderer) {\n        return context.equals(renderer.out(vocab.rdf2h(\"context\")).node);\n      });\n    }\n\n    var reverseGraphs = self.rendererGraphs;\n    return types.reduce(function (renderer, type) {\n      return renderer ? renderer : reverseGraphs.reduce(function (renderer, graph) {\n        var typeGN = GraphNode(type, graph);\n        return renderer ? renderer : getMatching(typeGN[\"in\"](vocab.rdf2h(\"type\")).split());\n      }, null);\n    }, null);\n  }\n\n  var types = getTypes(renderee.graphNode);\n  var renderer = getMatchingRenderer(types, renderee.context);\n\n  if (!renderer) {\n    throw Error(\"No renderer found with context: <\" + renderee.context.value + \"> for any of the types \" + types.map(function (t) {\n      return \"<\" + t.value + \">\";\n    }).join() + \". The resource <\" + renderee.graphNode.value + \"> could thus not be rendered.\");\n  }\n\n  var mustache = renderer.out(vocab.rdf2h(\"mustache\"));\n\n  if (mustache.nodes.length > 0) {\n    return rendererRenderer(mustache.value);\n  }\n\n  var js = renderer.out(vocab.rdf2h(\"javaScript\"));\n  return function (renderee) {\n    try {\n      var render = function render(n, context) {\n        return renderee.rdf2h.render(n.graph, n.node, context ? context : renderee.context);\n      };\n\n      var output = \"\";\n\n      var print = function print(s) {\n        output += s;\n      }; //Also printing return value for now\n\n\n      var returnValue = new Function(\"n\", \"context\", \"$rdf\", \"render\", \"print\", \"GraphNode\", \"env\", js.value)(renderee.graphNode, renderee.context, rdf, render, print, GraphNode, renderee.rdf2h.env);\n\n      if (returnValue) {\n        return output + returnValue;\n      } else {\n        return output;\n      }\n    } catch (err) {\n      err.message = err.message + \" in \" + js.value;\n      var stackLines = err.stack.split(\"\\n\");\n      var lineWithSelf = stackLines.findIndex(function (l) {\n        return l.indexOf(\"RDF2h.render\") > 0;\n      });\n      err.stack = stackLines.splice(0, lineWithSelf - 1).join(\"\\n\");\n      throw err;\n    }\n  };\n};\n\nRDF2h.prototype.render = function (graph, node, context) {\n  if (!node.termType) {\n    node = rdf.sym(node);\n  }\n\n  if (!context) {\n    context = vocab.rdf2h(\"Default\");\n  } //wrap all in one object that gets special care by lookup\n\n\n  var renderee = new RDF2h.Renderee(this, GraphNode(node, graph), context);\n  var renderer = this.getRenderer(renderee);\n  return renderer(renderee);\n};\n\nRDF2h.prefixMap = {};\nRDF2h.prefixMap[\"rdf\"] = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\nRDF2h.prefixMap[\"rdfs\"] = \"http://www.w3.org/2000/01/rdf-schema#\";\nRDF2h.prefixMap[\"r2h\"] = \"http://rdf2h.github.io/2015/rdf2h#\";\nRDF2h.prefixMap[\"schema\"] = \"http://schema.org/\";\nRDF2h.prefixMap[\"rdf\"] = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\nRDF2h.prefixMap[\"dct\"] = \"http://purl.org/dc/terms/\";\n\nRDF2h.resolveCurie = function (curie) {\n  if (curie.startsWith(\"<\") && curie.endsWith(\">\")) {\n    //URI, not a curie\n    return rdf.sym(curie.substring(1, curie.length - 1));\n  }\n\n  var splits = curie.split(\":\");\n  var prefix = splits[0];\n  var suffix = splits[1];\n\n  if (RDF2h.prefixMap[prefix]) {\n    return rdf.sym(RDF2h.prefixMap[prefix] + suffix);\n  } else {\n    return rdf.sym(curie);\n  }\n};\n\nif (typeof window !== 'undefined') {\n  window.RDF2h = RDF2h;\n}\n\nif (typeof module !== 'undefined') {\n  module.exports = RDF2h;\n}\n//# sourceMappingURL=rdf2h.js.map","module.exports = fetch;","/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false Mustache: true*/\n\n(function defineMustache (global, factory) {\n  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {\n    factory(exports); // CommonJS\n  } else if (typeof define === 'function' && define.amd) {\n    define(['exports'], factory); // AMD\n  } else {\n    global.Mustache = {};\n    factory(global.Mustache); // script, wsh, asp\n  }\n}(this, function mustacheFactory (mustache) {\n\n  var objectToString = Object.prototype.toString;\n  var isArray = Array.isArray || function isArrayPolyfill (object) {\n    return objectToString.call(object) === '[object Array]';\n  };\n\n  function isFunction (object) {\n    return typeof object === 'function';\n  }\n\n  /**\n   * More correct typeof string handling array\n   * which normally returns typeof 'object'\n   */\n  function typeStr (obj) {\n    return isArray(obj) ? 'array' : typeof obj;\n  }\n\n  function escapeRegExp (string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n  }\n\n  /**\n   * Null safe way of checking whether or not an object,\n   * including its prototype, has a given property\n   */\n  function hasProperty (obj, propName) {\n    return obj != null && typeof obj === 'object' && (propName in obj);\n  }\n\n  /**\n   * Safe way of detecting whether or not the given thing is a primitive and\n   * whether it has the given property\n   */\n  function primitiveHasOwnProperty (primitive, propName) {  \n    return (\n      primitive != null\n      && typeof primitive !== 'object'\n      && primitive.hasOwnProperty\n      && primitive.hasOwnProperty(propName)\n    );\n  }\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  var regExpTest = RegExp.prototype.test;\n  function testRegExp (re, string) {\n    return regExpTest.call(re, string);\n  }\n\n  var nonSpaceRe = /\\S/;\n  function isWhitespace (string) {\n    return !testRegExp(nonSpaceRe, string);\n  }\n\n  var entityMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n  };\n\n  function escapeHtml (string) {\n    return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\n      return entityMap[s];\n    });\n  }\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var equalsRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  /**\n   * Breaks up the given `template` string into a tree of tokens. If the `tags`\n   * argument is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n   * course, the default is to use mustaches (i.e. mustache.tags).\n   *\n   * A token is an array with at least 4 elements. The first element is the\n   * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n   * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n   * all text that appears outside a symbol this element is \"text\".\n   *\n   * The second element of a token is its \"value\". For mustache tags this is\n   * whatever else was inside the tag besides the opening symbol. For text tokens\n   * this is the text itself.\n   *\n   * The third and fourth elements of the token are the start and end indices,\n   * respectively, of the token in the original template.\n   *\n   * Tokens that are the root node of a subtree contain two more elements: 1) an\n   * array of tokens in the subtree and 2) the index in the original template at\n   * which the closing tag for that section begins.\n   */\n  function parseTemplate (template, tags) {\n    if (!template)\n      return [];\n\n    var sections = [];     // Stack to hold section tokens\n    var tokens = [];       // Buffer to hold the tokens\n    var spaces = [];       // Indices of whitespace tokens on the current line\n    var hasTag = false;    // Is there a {{tag}} on the current line?\n    var nonSpace = false;  // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace () {\n      if (hasTag && !nonSpace) {\n        while (spaces.length)\n          delete tokens[spaces.pop()];\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var openingTagRe, closingTagRe, closingCurlyRe;\n    function compileTags (tagsToCompile) {\n      if (typeof tagsToCompile === 'string')\n        tagsToCompile = tagsToCompile.split(spaceRe, 2);\n\n      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\n        throw new Error('Invalid tags: ' + tagsToCompile);\n\n      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n      closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n      closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n    }\n\n    compileTags(tags || mustache.tags);\n\n    var scanner = new Scanner(template);\n\n    var start, type, value, chr, token, openSection;\n    while (!scanner.eos()) {\n      start = scanner.pos;\n\n      // Match any text between tags.\n      value = scanner.scanUntil(openingTagRe);\n\n      if (value) {\n        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push([ 'text', chr, start, start + 1 ]);\n          start += 1;\n\n          // Check for whitespace on the current line.\n          if (chr === '\\n')\n            stripSpace();\n        }\n      }\n\n      // Match the opening tag.\n      if (!scanner.scan(openingTagRe))\n        break;\n\n      hasTag = true;\n\n      // Get the tag type.\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe);\n\n      // Get the tag value.\n      if (type === '=') {\n        value = scanner.scanUntil(equalsRe);\n        scanner.scan(equalsRe);\n        scanner.scanUntil(closingTagRe);\n      } else if (type === '{') {\n        value = scanner.scanUntil(closingCurlyRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(closingTagRe);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(closingTagRe);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(closingTagRe))\n        throw new Error('Unclosed tag at ' + scanner.pos);\n\n      token = [ type, value, start, scanner.pos ];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        openSection = sections.pop();\n\n        if (!openSection)\n          throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n        if (openSection[1] !== value)\n          throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } else if (type === '=') {\n        // Set the tags for the next time around.\n        compileTags(value);\n      }\n    }\n\n    // Make sure there are no open sections when we're done.\n    openSection = sections.pop();\n\n    if (openSection)\n      throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n    return nestTokens(squashTokens(tokens));\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens (tokens) {\n    var squashedTokens = [];\n\n    var token, lastToken;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          squashedTokens.push(token);\n          lastToken = token;\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n  function nestTokens (tokens) {\n    var nestedTokens = [];\n    var collector = nestedTokens;\n    var sections = [];\n\n    var token, section;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n        case '#':\n        case '^':\n          collector.push(token);\n          sections.push(token);\n          collector = token[4] = [];\n          break;\n        case '/':\n          section = sections.pop();\n          section[5] = token[2];\n          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n          break;\n        default:\n          collector.push(token);\n      }\n    }\n\n    return nestedTokens;\n  }\n\n  /**\n   * A simple string scanner that is used by the template parser to find\n   * tokens in template strings.\n   */\n  function Scanner (string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function eos () {\n    return this.tail === '';\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function scan (re) {\n    var match = this.tail.match(re);\n\n    if (!match || match.index !== 0)\n      return '';\n\n    var string = match[0];\n\n    this.tail = this.tail.substring(string.length);\n    this.pos += string.length;\n\n    return string;\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function scanUntil (re) {\n    var index = this.tail.search(re), match;\n\n    switch (index) {\n      case -1:\n        match = this.tail;\n        this.tail = '';\n        break;\n      case 0:\n        match = '';\n        break;\n      default:\n        match = this.tail.substring(0, index);\n        this.tail = this.tail.substring(index);\n    }\n\n    this.pos += match.length;\n\n    return match;\n  };\n\n  /**\n   * Represents a rendering context by wrapping a view object and\n   * maintaining a reference to the parent context.\n   */\n  function Context (view, parentContext) {\n    this.view = view;\n    this.cache = { '.': this.view };\n    this.parent = parentContext;\n  }\n\n  /**\n   * Creates a new context using the given view with this context\n   * as the parent.\n   */\n  Context.prototype.push = function push (view) {\n    return new Context(view, this);\n  };\n\n  /**\n   * Returns the value of the given name in this context, traversing\n   * up the context hierarchy if the value is absent in this context's view.\n   */\n  Context.prototype.lookup = function lookup (name) {\n    var cache = this.cache;\n\n    var value;\n    if (cache.hasOwnProperty(name)) {\n      value = cache[name];\n    } else {\n      var context = this, intermediateValue, names, index, lookupHit = false;\n\n      while (context) {\n        if (name.indexOf('.') > 0) {\n          intermediateValue = context.view;\n          names = name.split('.');\n          index = 0;\n\n          /**\n           * Using the dot notion path in `name`, we descend through the\n           * nested objects.\n           *\n           * To be certain that the lookup has been successful, we have to\n           * check if the last object in the path actually has the property\n           * we are looking for. We store the result in `lookupHit`.\n           *\n           * This is specially necessary for when the value has been set to\n           * `undefined` and we want to avoid looking up parent contexts.\n           *\n           * In the case where dot notation is used, we consider the lookup\n           * to be successful even if the last \"object\" in the path is\n           * not actually an object but a primitive (e.g., a string, or an\n           * integer), because it is sometimes useful to access a property\n           * of an autoboxed primitive, such as the length of a string.\n           **/\n          while (intermediateValue != null && index < names.length) {\n            if (index === names.length - 1)\n              lookupHit = (\n                hasProperty(intermediateValue, names[index]) \n                || primitiveHasOwnProperty(intermediateValue, names[index])\n              );\n\n            intermediateValue = intermediateValue[names[index++]];\n          }\n        } else {\n          intermediateValue = context.view[name];\n\n          /**\n           * Only checking against `hasProperty`, which always returns `false` if\n           * `context.view` is not an object. Deliberately omitting the check\n           * against `primitiveHasOwnProperty` if dot notation is not used.\n           *\n           * Consider this example:\n           * ```\n           * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\n           * ```\n           *\n           * If we were to check also against `primitiveHasOwnProperty`, as we do\n           * in the dot notation case, then render call would return:\n           *\n           * \"The length of a football field is 9.\"\n           *\n           * rather than the expected:\n           *\n           * \"The length of a football field is 100 yards.\"\n           **/\n          lookupHit = hasProperty(context.view, name);\n        }\n\n        if (lookupHit) {\n          value = intermediateValue;\n          break;\n        }\n\n        context = context.parent;\n      }\n\n      cache[name] = value;\n    }\n\n    if (isFunction(value))\n      value = value.call(this.view);\n\n    return value;\n  };\n\n  /**\n   * A Writer knows how to take a stream of tokens and render them to a\n   * string, given a context. It also maintains a cache of templates to\n   * avoid the need to parse the same template twice.\n   */\n  function Writer () {\n    this.cache = {};\n  }\n\n  /**\n   * Clears all cached templates in this writer.\n   */\n  Writer.prototype.clearCache = function clearCache () {\n    this.cache = {};\n  };\n\n  /**\n   * Parses and caches the given `template` according to the given `tags` or\n   * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\n   * that is generated from the parse.\n   */\n  Writer.prototype.parse = function parse (template, tags) {\n    var cache = this.cache;\n    var cacheKey = template + ':' + (tags || mustache.tags).join(':');\n    var tokens = cache[cacheKey];\n\n    if (tokens == null)\n      tokens = cache[cacheKey] = parseTemplate(template, tags);\n\n    return tokens;\n  };\n\n  /**\n   * High-level method that is used to render the given `template` with\n   * the given `view`.\n   *\n   * The optional `partials` argument may be an object that contains the\n   * names and templates of partials that are used in the template. It may\n   * also be a function that is used to load partial templates on the fly\n   * that takes a single argument: the name of the partial.\n   *\n   * If the optional `tags` argument is given here it must be an array with two\n   * string values: the opening and closing tags used in the template (e.g.\n   * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n   */\n  Writer.prototype.render = function render (template, view, partials, tags) {\n    var tokens = this.parse(template, tags);\n    var context = (view instanceof Context) ? view : new Context(view);\n    return this.renderTokens(tokens, context, partials, template, tags);\n  };\n\n  /**\n   * Low-level method that renders the given array of `tokens` using\n   * the given `context` and `partials`.\n   *\n   * Note: The `originalTemplate` is only ever used to extract the portion\n   * of the original template that was contained in a higher-order section.\n   * If the template doesn't use higher-order sections, this argument may\n   * be omitted.\n   */\n  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, tags) {\n    var buffer = '';\n\n    var token, symbol, value;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      value = undefined;\n      token = tokens[i];\n      symbol = token[0];\n\n      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);\n      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);\n      else if (symbol === '>') value = this.renderPartial(token, context, partials, tags);\n      else if (symbol === '&') value = this.unescapedValue(token, context);\n      else if (symbol === 'name') value = this.escapedValue(token, context);\n      else if (symbol === 'text') value = this.rawValue(token);\n\n      if (value !== undefined)\n        buffer += value;\n    }\n\n    return buffer;\n  };\n\n  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {\n    var self = this;\n    var buffer = '';\n    var value = context.lookup(token[1]);\n\n    // This function is used to render an arbitrary template\n    // in the current context by higher-order sections.\n    function subRender (template) {\n      return self.render(template, context, partials);\n    }\n\n    if (!value) return;\n\n    if (isArray(value)) {\n      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);\n      }\n    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);\n    } else if (isFunction(value)) {\n      if (typeof originalTemplate !== 'string')\n        throw new Error('Cannot use higher-order sections without the original template');\n\n      // Extract the portion of the original template that the section contains.\n      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n      if (value != null)\n        buffer += value;\n    } else {\n      buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n    }\n    return buffer;\n  };\n\n  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {\n    var value = context.lookup(token[1]);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || (isArray(value) && value.length === 0))\n      return this.renderTokens(token[4], context, partials, originalTemplate);\n  };\n\n  Writer.prototype.renderPartial = function renderPartial (token, context, partials, tags) {\n    if (!partials) return;\n\n    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n    if (value != null)\n      return this.renderTokens(this.parse(value, tags), context, partials, value);\n  };\n\n  Writer.prototype.unescapedValue = function unescapedValue (token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return value;\n  };\n\n  Writer.prototype.escapedValue = function escapedValue (token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return mustache.escape(value);\n  };\n\n  Writer.prototype.rawValue = function rawValue (token) {\n    return token[1];\n  };\n\n  mustache.name = 'mustache.js';\n  mustache.version = '3.0.1';\n  mustache.tags = [ '{{', '}}' ];\n\n  // All high-level mustache.* functions use this writer.\n  var defaultWriter = new Writer();\n\n  /**\n   * Clears all cached templates in the default writer.\n   */\n  mustache.clearCache = function clearCache () {\n    return defaultWriter.clearCache();\n  };\n\n  /**\n   * Parses and caches the given template in the default writer and returns the\n   * array of tokens it contains. Doing this ahead of time avoids the need to\n   * parse templates on the fly as they are rendered.\n   */\n  mustache.parse = function parse (template, tags) {\n    return defaultWriter.parse(template, tags);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer. If the optional `tags` argument is given here it must be an\n   * array with two string values: the opening and closing tags used in the\n   * template (e.g. [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n   */\n  mustache.render = function render (template, view, partials, tags) {\n    if (typeof template !== 'string') {\n      throw new TypeError('Invalid template! Template should be a \"string\" ' +\n                          'but \"' + typeStr(template) + '\" was given as the first ' +\n                          'argument for mustache#render(template, view, partials)');\n    }\n\n    return defaultWriter.render(template, view, partials, tags);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.,\n  /*eslint-disable */ // eslint wants camel cased function name\n  mustache.to_html = function to_html (template, view, partials, send) {\n    /*eslint-enable*/\n\n    var result = mustache.render(template, view, partials);\n\n    if (isFunction(send)) {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  mustache.escape = escapeHtml;\n\n  // Export these mainly for testing, but also for advanced usage.\n  mustache.Scanner = Scanner;\n  mustache.Context = Context;\n  mustache.Writer = Writer;\n\n  return mustache;\n}));\n","\"use strict\";\n\nvar $rdf = require(\"ext-rdflib\");\n\nmodule.exports = {\n  schema: function schema(suffix) {\n    return $rdf.sym(\"http://schema.org/\" + suffix);\n  },\n  rdf: function rdf(suffix) {\n    return $rdf.sym(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" + suffix);\n  },\n  rdfs: function rdfs(suffix) {\n    return $rdf.sym(\"http://www.w3.org/2000/01/rdf-schema#\" + suffix);\n  },\n  foaf: function foaf(suffix) {\n    return $rdf.sym(\"http://xmlns.com/foaf/0.1/\" + suffix);\n  },\n  rdf2h: function rdf2h(suffix) {\n    return $rdf.sym(\"http://rdf2h.github.io/2015/rdf2h#\" + suffix);\n  }\n};\n//# sourceMappingURL=vocab.js.map"],"sourceRoot":""}